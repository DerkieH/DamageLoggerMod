package nl.alliantie.damagelogger;

import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.entity.event.v1.ServerLivingEntityEvents;
import net.fabricmc.fabric.api.entity.event.v1.ServerPlayerEvents;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents;
import net.fabricmc.fabric.api.networking.v1.ServerPlayConnectionEvents;

import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.damage.DamageSource;
import net.minecraft.entity.projectile.ProjectileEntity;
import net.minecraft.network.packet.s2c.play.PositionFlag;
import net.minecraft.registry.RegistryKey;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.MutableText;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.minecraft.world.GameMode;
import net.minecraft.world.GameRules;
import net.minecraft.world.World;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

public class DamageLoggerMod implements ModInitializer {

    // ---- Damage anti-spam ----
    private static final long DEFAULT_COOLDOWN_MS = 300;
    private static final long DOT_COOLDOWN_MS = 1500;
    private static final Map<String, Long> LAST_LOG_TIME = new ConcurrentHashMap<>();

    // ---- Filters ----
    private static final String GENERIC_KILL = "minecraft:genericKill";

    // ---- Run state ----
    private static final AtomicBoolean FIRST_REAL_DEATH_HANDLED = new AtomicBoolean(false);

    // Start time set when the first player joins after server start
    private static volatile long runStartMs = -1L;

    // Once failed, we freeze the time
    private static volatile boolean runFailed = false;
    private static volatile long runEndMs = -1L;

    // Death location for spectator freeze
    private static volatile RegistryKey<World> deathWorldKey = null;
    private static volatile double deathX = 0;
    private static volatile double deathY = 0;
    private static volatile double deathZ = 0;
    private static volatile float deathYaw = 0;
    private static volatile float deathPitch = 0;

    // After RUN FAILED: keep players pinned for 5 seconds (no flying away)
    private static volatile long pinUntilMs = -1L;

    // Actionbar update every second
    private static int tickCounter = 0;

    // ---- Leaderboard: total damage taken per player for this run (in hearts) ----
    private static final Map<UUID, Double> TOTAL_DAMAGE_HEARTS = new ConcurrentHashMap<>();
    private static final Map<UUID, String> LAST_KNOWN_NAME = new ConcurrentHashMap<>();
    private static final int LEADERBOARD_SIZE = 10;

    @Override
    public void onInitialize() {

        // Ensure gamerule is enabled as soon as server is up
        ServerLifecycleEvents.SERVER_STARTED.register(server ->
                server.getGameRules().get(GameRules.DO_IMMEDIATE_RESPAWN).set(true, server)
        );

        // Start timer on first join + keep gamerule enabled
        ServerPlayConnectionEvents.JOIN.register((handler, sender, server) -> {
            ServerPlayerEntity p = handler.getPlayer();
            LAST_KNOWN_NAME.put(p.getUuid(), p.getName().getString());

            server.getGameRules().get(GameRules.DO_IMMEDIATE_RESPAWN).set(true, server);

            if (runStartMs < 0) {
                runStartMs = System.currentTimeMillis();
            }
        });

        // If someone respawns while runFailed is active: force spectator + teleport
        ServerPlayerEvents.AFTER_RESPAWN.register((oldPlayer, newPlayer, alive) -> {
            if (!runFailed) return;
            teleportAndSpectateIfPossible(newPlayer);
        });

        // Actionbar timer tick + pin enforcement
        ServerTickEvents.END_SERVER_TICK.register((MinecraftServer server) -> {
            enforcePinIfNeeded(server);

            tickCounter++;
            if (tickCounter < 20) return;
            tickCounter = 0;

            if (runStartMs < 0) return;

            long now = System.currentTimeMillis();
            long elapsed = runFailed && runEndMs > 0 ? (runEndMs - runStartMs) : (now - runStartMs);
            if (elapsed < 0) elapsed = 0;

            String timeStr = formatDuration(elapsed);

            MutableText bar = !runFailed
                    ? Text.literal(timeStr).formatted(Formatting.GOLD)
                    : Text.empty()
                        .append(Text.literal("RUN FAILED ").formatted(Formatting.DARK_RED, Formatting.BOLD))
                        .append(Text.literal("‚Äî ").formatted(Formatting.DARK_GRAY))
                        .append(Text.literal(timeStr).formatted(Formatting.GOLD));

            for (ServerPlayerEntity p : server.getPlayerManager().getPlayerList()) {
                p.sendMessage(bar, true);
            }
        });

        // Damage logs
        ServerLivingEntityEvents.ALLOW_DAMAGE.register((LivingEntity entity, DamageSource source, float amount) -> {
            if (!(entity instanceof ServerPlayerEntity player)) return true;
            if (!(entity.getEntityWorld() instanceof ServerWorld serverWorld)) return true;

            MinecraftServer server = serverWorld.getServer();
            if (server == null) return true;

            String damageType = describeDamageType(source);
            if (isGenericKill(damageType)) return true;

            double hearts = amount / 2.0;
            if (hearts > 0) addDamageToTotals(player, hearts);

            long cooldown = isDotType(damageType) ? DOT_COOLDOWN_MS : DEFAULT_COOLDOWN_MS;
            if (shouldThrottle(player.getUuid(), damageType, cooldown)) return true;

            String playerName = player.getName().getString();
            String cause = describeCause(source);

            MutableText msg = Text.empty()
                    .append(Text.literal("‚ò† ").formatted(Formatting.DARK_GRAY))
                    .append(Text.literal(playerName).formatted(Formatting.WHITE))
                    .append(Text.literal(" took ").formatted(Formatting.GRAY))
                    .append(Text.literal(String.format("%.1f ‚ù§", hearts)).formatted(Formatting.RED))
                    .append(Text.literal(" damage from ").formatted(Formatting.GRAY))
                    .append(Text.literal(cause).formatted(Formatting.GRAY))
                    .append(Text.literal(" (").formatted(Formatting.DARK_GRAY))
                    .append(Text.literal(damageType).formatted(Formatting.DARK_GRAY))
                    .append(Text.literal(")").formatted(Formatting.DARK_GRAY));

            server.getPlayerManager().broadcast(msg, false);
            return true;
        });

        // Death handling
        ServerLivingEntityEvents.AFTER_DEATH.register((LivingEntity entity, DamageSource source) -> {
            if (!(entity instanceof ServerPlayerEntity player)) return;
            if (!(entity.getEntityWorld() instanceof ServerWorld serverWorld)) return;

            MinecraftServer server = serverWorld.getServer();
            if (server == null) return;

            String deathType = describeDamageType(source);
            if (isGenericKill(deathType)) return;
            if (!FIRST_REAL_DEATH_HANDLED.compareAndSet(false, true)) return;

            server.getGameRules().get(GameRules.DO_IMMEDIATE_RESPAWN).set(true, server);

            runFailed = true;
            runEndMs = System.currentTimeMillis();

            deathWorldKey = serverWorld.getRegistryKey();
            deathX = player.getX();
            deathY = player.getY();
            deathZ = player.getZ();
            deathYaw = player.getYaw();
            deathPitch = player.getPitch();

            pinUntilMs = System.currentTimeMillis() + 5000;

            broadcastEndRunDramatic(server, player, serverWorld, source, deathType);

            server.getPlayerManager().broadcast(
                    Text.literal("‚Äî Most damage taken this run ‚Äî").formatted(Formatting.DARK_GRAY),
                    false
            );
            broadcastDamageLeaderboard(server);

            applySpectatorFreeze(server);

            // Helps in odd timing cases
            teleportAndSpectateIfPossible(player);
        });
    }

    // ------------------------------------------------------------
    // Force spectator + teleport to death point (NO getServer() usage)
    // ------------------------------------------------------------

    private static void teleportAndSpectateIfPossible(ServerPlayerEntity p) {
        if (!runFailed) return;
        if (deathWorldKey == null) return;

        // Get server via player's current world
        if (!(p.getEntityWorld() instanceof ServerWorld currentWorld)) return;
        MinecraftServer server = currentWorld.getServer();
        if (server == null) return;

        ServerWorld targetWorld = server.getWorld(deathWorldKey);
        if (targetWorld == null) return;

        p.changeGameMode(GameMode.SPECTATOR);
        p.teleport(targetWorld, deathX, deathY, deathZ, Set.<PositionFlag>of(), deathYaw, deathPitch, true);
    }

    // ------------------------------------------------------------
    // Dramatic END RUN
    // ------------------------------------------------------------

    private static void broadcastEndRunDramatic(MinecraftServer server, ServerPlayerEntity dead, ServerWorld world, DamageSource source, String deathType) {
        String dim = world.getRegistryKey().getValue().toString();

        server.getPlayerManager().broadcast(Text.literal(" ").formatted(Formatting.DARK_GRAY), false);
        server.getPlayerManager().broadcast(Text.literal("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê").formatted(Formatting.DARK_RED), false);
        server.getPlayerManager().broadcast(Text.literal("‚ò†‚ò†‚ò†  END RUN  ‚ò†‚ò†‚ò†").formatted(Formatting.RED, Formatting.BOLD), false);
        server.getPlayerManager().broadcast(Text.literal("RUN FAILED").formatted(Formatting.DARK_RED, Formatting.BOLD), false);
        server.getPlayerManager().broadcast(Text.literal("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê").formatted(Formatting.DARK_RED), false);

        MutableText deathLine = Text.empty()
                .append(Text.literal("üíÄ DEATH: ").formatted(Formatting.DARK_RED))
                .append(Text.literal(dead.getName().getString()).formatted(Formatting.WHITE))
                .append(Text.literal(" @ ").formatted(Formatting.GRAY))
                .append(Text.literal(dead.getBlockX() + " " + dead.getBlockY() + " " + dead.getBlockZ()).formatted(Formatting.GOLD))
                .append(Text.literal(" in ").formatted(Formatting.GRAY))
                .append(Text.literal(dim).formatted(Formatting.GOLD))
                .append(Text.literal(" ‚Äî cause: ").formatted(Formatting.GRAY))
                .append(Text.literal(describeCause(source)).formatted(Formatting.GRAY))
                .append(Text.literal(" (").formatted(Formatting.DARK_GRAY))
                .append(Text.literal(deathType).formatted(Formatting.DARK_GRAY))
                .append(Text.literal(")").formatted(Formatting.DARK_GRAY));

        server.getPlayerManager().broadcast(deathLine, false);

        server.getPlayerManager().broadcast(
                Text.literal("The run is over. Reset and go again.").formatted(Formatting.GRAY, Formatting.ITALIC),
                false
        );
        server.getPlayerManager().broadcast(Text.literal(" ").formatted(Formatting.DARK_GRAY), false);
    }

    // ------------------------------------------------------------
    // Spectator freeze + pin
    // ------------------------------------------------------------

    private static void applySpectatorFreeze(MinecraftServer server) {
        RegistryKey<World> targetKey = deathWorldKey;
        if (targetKey == null) return;

        ServerWorld targetWorld = server.getWorld(targetKey);
        if (targetWorld == null) return;

        for (ServerPlayerEntity p : server.getPlayerManager().getPlayerList()) {
            p.changeGameMode(GameMode.SPECTATOR);
            p.teleport(targetWorld, deathX, deathY, deathZ, Set.<PositionFlag>of(), deathYaw, deathPitch, true);
        }
    }

    private static void enforcePinIfNeeded(MinecraftServer server) {
        if (!runFailed) return;
        long until = pinUntilMs;
        if (until <= 0) return;

        long now = System.currentTimeMillis();
        if (now >= until) return;

        RegistryKey<World> targetKey = deathWorldKey;
        if (targetKey == null) return;

        ServerWorld targetWorld = server.getWorld(targetKey);
        if (targetWorld == null) return;

        for (ServerPlayerEntity p : server.getPlayerManager().getPlayerList()) {
            p.changeGameMode(GameMode.SPECTATOR);
            p.teleport(targetWorld, deathX, deathY, deathZ, Set.<PositionFlag>of(), deathYaw, deathPitch, true);
        }
    }

    // ------------------------------------------------------------
    // Leaderboard
    // ------------------------------------------------------------

    private static void addDamageToTotals(ServerPlayerEntity player, double hearts) {
        if (hearts <= 0) return;
        UUID id = player.getUuid();
        LAST_KNOWN_NAME.put(id, player.getName().getString());
        TOTAL_DAMAGE_HEARTS.merge(id, hearts, Double::sum);
    }

    private static void broadcastDamageLeaderboard(MinecraftServer server) {
        List<Map.Entry<UUID, Double>> entries = new ArrayList<>(TOTAL_DAMAGE_HEARTS.entrySet());
        entries.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));

        int count = Math.min(LEADERBOARD_SIZE, entries.size());
        if (count <= 0) return;

        for (int i = 0; i < count; i++) {
            Map.Entry<UUID, Double> e = entries.get(i);
            String name = LAST_KNOWN_NAME.getOrDefault(e.getKey(), e.getKey().toString());
            double hearts = e.getValue();

            MutableText line = Text.empty()
                    .append(Text.literal(String.format("%2d. ", i + 1)).formatted(Formatting.DARK_GRAY))
                    .append(Text.literal(name).formatted(Formatting.WHITE))
                    .append(Text.literal(" ‚Äî ").formatted(Formatting.DARK_GRAY))
                    .append(Text.literal(String.format("%.1f ‚ù§", hearts)).formatted(Formatting.RED));

            server.getPlayerManager().broadcast(line, false);
        }
    }

    // ------------------------------------------------------------
    // Helpers
    // ------------------------------------------------------------

    private static boolean shouldThrottle(UUID playerId, String damageType, long cooldownMs) {
        long now = System.currentTimeMillis();
        String key = playerId + "|" + damageType;

        Long last = LAST_LOG_TIME.get(key);
        if (last != null && (now - last) < cooldownMs) return true;

        LAST_LOG_TIME.put(key, now);
        return false;
    }

    private static boolean isGenericKill(String damageType) {
        if (damageType == null) return false;
        return GENERIC_KILL.equals(damageType) || damageType.endsWith(":genericKill");
    }

    private static boolean isDotType(String damageType) {
        if (damageType == null) return false;
        String lower = damageType.toLowerCase(Locale.ROOT);
        return lower.contains("lava")
                || lower.contains("fire")
                || lower.contains("hotfloor")
                || lower.contains("infire")
                || lower.contains("onfire");
    }

    private static String describeDamageType(DamageSource source) {
        try {
            return "minecraft:" + source.getType().msgId();
        } catch (Throwable t) {
            try {
                return source.getName();
            } catch (Throwable t2) {
                return "unknown";
            }
        }
    }

    private static String describeCause(DamageSource source) {
        Entity attacker = source.getAttacker();
        Entity direct = source.getSource();

        if (attacker != null) {
            String name = attacker.getName().getString();
            if (attacker instanceof ServerPlayerEntity) return name + " (player)";
            return name;
        }

        if (direct != null) {
            if (direct instanceof ProjectileEntity) return direct.getName().getString() + " (projectile)";
            return direct.getName().getString();
        }

        return source.getName();
    }

    private static String formatDuration(long ms) {
        long totalSeconds = ms / 1000;
        long hours = totalSeconds / 3600;
        long minutes = (totalSeconds % 3600) / 60;
        long seconds = totalSeconds % 60;
        return String.format("%02d:%02d:%02d", hours, minutes, seconds);
    }
}
